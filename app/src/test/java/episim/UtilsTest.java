/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package episim;

import episim.util.MathUtils;
import org.junit.Test;

import java.util.Random;

import static org.junit.Assert.*;

public class UtilsTest {
    private final Random rand = new Random();

    @Test public void testSnapToTicks() {
        int ntests = 0;
        while(ntests < 1000) {
            double min = rand.nextDouble() * 2000 - 1000;
            double max = min + rand.nextDouble() * 1000;
            double step = rand.nextDouble() * (max - min);
            if(step == 0) {
                continue;
            }
            double baseValue = step * (double)rand.nextInt((int)Math.floor((max - min) / step));
            double value = baseValue + rand.nextDouble() * step;
            double result = MathUtils.snapToTicks(value, min, max, step);
            double ulp =  Math.ulp(result); // On test à la précision flottante près
            assertTrue(
                    "snapToTicks test failed value:<" + value + "> " +
                            "step:<" + step + "> " +
                            "result:<" + result + "> " +
                            "baseValue:<" + baseValue + "> " +
                            "ulp:<" + ulp + ">",
                    (result >= baseValue - ulp && result <= baseValue + ulp) ||
                            (result >= baseValue + step - ulp && result <= baseValue + step + ulp) ||
                            (result == min && baseValue <= min) ||
                            (result == max && baseValue >= max)
            );
            ntests++;
        }
    }

    @Test public void testFloatMod() {
        int ntests = 0;
        while(ntests < 1000) {
            double div = rand.nextDouble() * 100;
            double expected = rand.nextDouble() * div;
            double value = div + expected;
            double result = MathUtils.floatMod(value, div);
            double ulp =  Math.ulp(result) + Math.ulp(value);
            assertEquals(
                    "floatMod test failed value:<" + value + "> " +
                            "div:<" + div + "> " +
                            "expected:<" + expected + "> " +
                            "result:<" + result + "> " +
                            "ulp:<" + ulp + ">",
                    expected, result, ulp
            );
            ntests++;
        }
    }

    @Test public void testAngleMod() {
        int ntests = 0;
        while(ntests < 1000) {
            int n = 10 - rand.nextInt(20);
            double expected = (2.0 * rand.nextDouble() - 1.0) * Math.PI;
            double angle = expected + (double)n * 2.0 * Math.PI;
            double result = MathUtils.angleMod(angle);
            double ulp =  Math.ulp(result) + Math.ulp(angle);
            assertEquals(
                    "angleMod test failed angle:<" + angle + "> " +
                    "n:<" + n + "> " +
                    "ulp:<" + ulp + ">",
                    expected, result, ulp
            );
            ntests++;
        }
    }
}
